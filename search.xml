<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023-兔年-新年新赛道(大陆实习日记)</title>
      <link href="2023/01/01/2023-tu-nian-xin-nian-xin-sai-dao/"/>
      <url>2023/01/01/2023-tu-nian-xin-nian-xin-sai-dao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>幸存者偏差：是由<a href="https://baike.baidu.com/item/%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/825801?fromModule=lemma_inlink">优胜劣汰</a>之后自然选择出的一个道理：未幸存者已无法发声。人们只看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。</p><h2 id="人生选择："><a href="#人生选择：" class="headerlink" title="人生选择："></a>人生选择：</h2><p>人生十字路口的心得感悟：</p><p>步入大四，在考研，考公，就业的三大选择上，我不由自主的陷入了人生的选择，在这个复杂的选择岔路口上，每一个不同的选择都通向了不同的人生，大概每个应届毕业生都面临着这个选择。<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F12752412677%2F641&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675155135&t=7da0571e0c3c949f75bda4d314d9aec8" alt="img"  /></p><h3 id="1-考研"><a href="#1-考研" class="headerlink" title="1.考研"></a>1.考研</h3><p>一个路口通向考研，学术研究道路，毕业即是某个计算机领域的硕士，有一定的学术研究能力和应用技术能力，如嵌入式应用，大数据开发，计算机视觉，机器学习等，走这条道路关键在于自己感兴趣的研究方向，以及本科阶段在相关技术实验室的积累。学制三年，这个方向，对于应届毕业生来说，是不错的选择，但是2023年考研人数接近500万人比2022年考研人数470万多了30万人，需要备考一年，再加三年的研究生培养，出来就是24岁的样子，也需要找相关研究领域的工作，也就拥有进入大厂或者名企的敲门砖，拥有不错的薪资待遇。从自身的各种收益看，近期收益低，但长远收益高。报录比5:1，五百万考生只有一百万可以上岸。所以考研人常说：考研失败是常态。</p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2F16%2F8c%2Faa%2F168caad95808c34c5bb5bea954a00681.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675159559&t=1074b82549f985e7cf7a4a8e2b0673b0" style="zoom: 25%;" /><h3 id="2-考公"><a href="#2-考公" class="headerlink" title="2.考公"></a>2.考公</h3><p>一个路口通向考公，考公务员进入国家机关单位或政府机构，参与政治事务，处理政治事务或当官为民。比如三支一扶，和大学生村官，事业单位招聘等国家政策，也是大家口中的”铁饭碗”。公务员要求有逻辑清晰的表达能力，和过人的语言理解能力，要参加国家统一的公务员考试和面试，报录比100:1，100个考生上岸1个，但是考上后，工作压力小，工作环境好，待遇也高。</p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp5.itc.cn%2Fimages01%2F20210623%2F4af41753cc9e41dab575ca3210248a6f.jpeg&refer=http%3A%2F%2Fp5.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675159678&t=87455e293161c680b232863209e9dcdd" alt="img" style="zoom:25%;" /><h3 id="3-就业"><a href="#3-就业" class="headerlink" title="3.就业"></a>3.就业</h3><p>最后一个路口就是就业，也是我选择的路口，当然并不顺利，秋招投递了自己想研究的领域以及想从事的方向，软件开发工程师，后端开发工程师，软件测试工程师，这三个方向又分了不同的职位：嵌入式开发工程师，Java开发工程师，C/C++开发工程师，软件测试工程师，系统测试工程师等。整个秋招我投递了3家互联网公司和1家我非常喜欢和向往的车企，分别是百度，腾讯，航信，Conti，百度一面被PASS，腾讯简历被刷，航信，二面被PASS，Continental也是二面被PASS，每个面试被PASS的原因都不同，但都是因为我自己硬实力和软实力的不足导致的，最后因为在专业实习和暑期实习期间在Conti取得了不错的成绩还是来到了Conti的系统测试部门实习，而且我目前的Leader也是我学习的榜样，工作严谨但谈话幽默，传道受业是师傅但茶余饭后是朋友，正所谓：师者，所以传道受业解惑也，人非生而知之者，孰能无惑？leader的亦师亦友，让我更加确定我想要在Conti长期发展，虽然我本科的研究方向是后端开发但我自己也热爱系统测试这份工作，也想在这个领域做到技术专家成为高级系统测试工程师，但是目前我对于车载测试还是个小白，还是个初级工程师，后续我会持续更新Conti的实习日记，记录自己从系统测试初级工程师到高级工程师的心得体会和心路历程，争取早日变成幸存者。<img src="https://img2.baidu.com/it/u=1038664049,39468676&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题七</title>
      <link href="2022/03/07/shua-ti-qi/"/>
      <url>2022/03/07/shua-ti-qi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-3-7"><a href="#刷题—2022-3-7" class="headerlink" title="刷题—2022-3-7"></a>刷题—2022-3-7</h1><h2 id="题目1-ISBN-数组-字符串"><a href="#题目1-ISBN-数组-字符串" class="headerlink" title="题目1(ISBN 数组,字符串)"></a>题目1(ISBN 数组,字符串)</h2><p>图书使用国际标准书号（International Standard Book Number (ISBN-10)）来编码，是一个 10 位码。前 9 位（0−9之间的数字）分别用于表示语言、出版商和 图书信息。第 10 位是校验位，可以是0−9之间的数字或者是字母 X （用于表示数字10）；</p><p>ISBN-10码可以通过下面方法进行验证：</p><ol><li>首先，对ISBN-10码的各个位按下面的计算式求和： 1×<em>x</em>1+2×<em>x</em>2+3×<em>x</em>3+4×<em>x</em>4⋯+9×<em>x</em>9+10×<em>x</em>10</li><li>将求和的结果对11取余数，如果余为0，则说明该ISBN-10码是一个有效码，否则，就不是一个有效的ISBN-10码。</li></ol><p>现输入一批ISBN-10图书编码，请你验证该编码是否是有效的国际标准书号。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出正整数N（≤10）是输入的ISBN-10图书编号的个数。随后N行，每行给出1个10位的ISBN-10图书编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照输入的顺序每行输出1个有问题的ISBN-10编码。这里<strong>并不检验前9位是否合理，只检查前9位是否全为数字且最后1位校验码计算准确</strong>。如果所有号码都正常，则输出 <code>All passed</code>。</p><h3 id="输入样例01"><a href="#输入样例01" class="headerlink" title="输入样例01:"></a>输入样例01:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0072880082</span><br></pre></td></tr></table></figure><h3 id="输出样例01"><a href="#输出样例01" class="headerlink" title="输出样例01:"></a>输出样例01:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All passed</span><br></pre></td></tr></table></figure><h3 id="输入样例02"><a href="#输入样例02" class="headerlink" title="输入样例02:"></a>输入样例02:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0072880082</span><br><span class="line">084930149X</span><br></pre></td></tr></table></figure><h3 id="输出样例02"><a href="#输出样例02" class="headerlink" title="输出样例02:"></a>输出样例02:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">084930149X</span><br></pre></td></tr></table></figure><h3 id="输入样例03"><a href="#输入样例03" class="headerlink" title="输入样例03:"></a>输入样例03:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">013168728X</span><br><span class="line">X615880991</span><br><span class="line">026201A530</span><br></pre></td></tr></table></figure><h3 id="输出样例03"><a href="#输出样例03" class="headerlink" title="输出样例03:"></a>输出样例03:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X615880991</span><br><span class="line">026201A530</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">IsIBSN</span><span class="params">(String isbn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="keyword">char</span> cc=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ii;</span><br><span class="line">            <span class="keyword">if</span>(isbn.charAt(i)==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                ii=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">             ii = (<span class="keyword">int</span>)isbn.charAt(i)-<span class="number">48</span>;</span><br><span class="line">            sum += ii * (i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = sum % <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> x=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> y=x;</span><br><span class="line">        String [] a=<span class="keyword">new</span> String[x];</span><br><span class="line">        String b=in.nextLine();<span class="comment">//读取回车</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]=in.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(!IsIBSN(a[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==x-<span class="number">1</span>)</span><br><span class="line">                    System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                System.out.println(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;All passed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-全排列递归"><a href="#题目2-全排列递归" class="headerlink" title="题目2(全排列递归)"></a>题目2(全排列递归)</h2><p>（一）递归的全排列算法</p><p>（A、B、C、D）的全排列为</p><p>1、A后面跟（B、C、D）的全排列</p><p>2、B后面跟（A、C、D）的全排列</p><p>3、C后面跟（A、B、D）的全排列</p><p>4、D后面跟（A、B、C）的全排列</p><p>而对1中的（B、C、D）照样可以按照上面的形式进行分解。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a , <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//全排列递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Perm</span><span class="params">(<span class="keyword">int</span> list[] , <span class="keyword">int</span> k ,<span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//list 数组存放排列的数，K表示层 代表第几个数，m表示数组的长度</span></span><br><span class="line"><span class="keyword">if</span>(k==m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//K==m 表示到达最后一个数，不能再交换，最终的排列的数需要输出；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;=m ;i++)</span><br><span class="line"> cout&lt;&lt;list[i];</span><br><span class="line"> cout&lt;&lt;endl; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">swap</span>(list[i],list[k]);</span><br><span class="line"> <span class="built_in">Perm</span>(list,k+<span class="number">1</span>,m);</span><br><span class="line"> <span class="built_in">swap</span>(list[i] , list[k]);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> m=<span class="number">2</span>;</span><br><span class="line">   <span class="built_in">Perm</span>(a,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  123</span></span><br><span class="line"><span class="comment">  132</span></span><br><span class="line"><span class="comment">  213</span></span><br><span class="line"><span class="comment">  231</span></span><br><span class="line"><span class="comment">  321</span></span><br><span class="line"><span class="comment">  312</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="题目3-贪心"><a href="#题目3-贪心" class="headerlink" title="题目3(贪心)"></a>题目3(贪心)</h2><p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 0 0 0 3 0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10015558</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>],i,b[<span class="number">50</span>],j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;scanf(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        b[<span class="number">0</span>]=i;</span><br><span class="line">        a[i]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    <span class="keyword">while</span>(a[i])</span><br><span class="line">    &#123;</span><br><span class="line">        b[j]=i;</span><br><span class="line">        j++;</span><br><span class="line">        a[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">       printf(<span class="string">&quot;%d&quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题六</title>
      <link href="2022/03/03/shua-ti-liu/"/>
      <url>2022/03/03/shua-ti-liu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-3-3"><a href="#刷题—2022-3-3" class="headerlink" title="刷题—2022-3-3"></a>刷题—2022-3-3</h1><h2 id="题目1-数组"><a href="#题目1-数组" class="headerlink" title="题目1(数组)"></a>题目1(数组)</h2><p>统计一个数组中出现次数最多的数字;</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Main().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner fin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> N = fin.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">++count[fin.nextInt()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; maxCount) &#123;</span><br><span class="line">maxCount = count[i];</span><br><span class="line">result = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-字符串拼接"><a href="#题目2-字符串拼接" class="headerlink" title="题目2(字符串拼接)"></a>题目2(字符串拼接)</h2><p>每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。<br>　　识别码的计算方法如下：<br>　　首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。<br>　　编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。</p><p>样例输入</p><p>0-670-82162-4</p><p>样例输出</p><p>Right</p><p>样例输入</p><p>0-670-82162-0</p><p>样例输出</p><p>0-670-82162-4</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">BufferedReader bin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="keyword">char</span> cc=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">String isbn_0 = bin.readLine();</span><br><span class="line">String isbn = isbn_0.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ii = (<span class="keyword">int</span>)isbn.charAt(i)-<span class="number">48</span>;</span><br><span class="line">sum += ii * (i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sum = sum % <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(sum == <span class="number">10</span>) cc = <span class="string">&#x27;X&#x27;</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> cc = (<span class="keyword">char</span>)(sum+<span class="number">48</span>);</span><br><span class="line"><span class="keyword">if</span>(cc == isbn.charAt(<span class="number">9</span>)) System.out.println(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">isbn_0 = isbn_0.substring(<span class="number">0</span>,<span class="number">12</span>) + cc;</span><br><span class="line">System.out.println(isbn_0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-优先队列，大根堆"><a href="#题目3-优先队列，大根堆" class="headerlink" title="题目3(优先队列，大根堆)"></a>题目3(优先队列，大根堆)</h2><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度或窗口长度为0的时候，返回空。</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。</p><p>假设窗口的大小为 M，数组的长度为 N。在窗口向右移动时，需要先在堆中删除离开窗口的元素，并将新到达的元素添加到堆中，这两个操作的时间复杂度都为 log2M，因此算法的时间复杂度为 O(Nlog2M)，空间复杂度为 O(M)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  <span class="comment">/* 大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heap.add(num[i]);</span><br><span class="line">    ret.add(heap.peek());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + size; j &lt; num.length; i++, j++) &#123;            <span class="comment">/* 维护一个大小为 size 的大顶堆 */</span></span><br><span class="line">        heap.remove(num[i]);</span><br><span class="line">        heap.add(num[j]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题五</title>
      <link href="2022/03/02/shua-ti-wu/"/>
      <url>2022/03/02/shua-ti-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-3-2"><a href="#刷题—2022-3-2" class="headerlink" title="刷题—2022-3-2"></a>刷题—2022-3-2</h1><h2 id="题目1-栈"><a href="#题目1-栈" class="headerlink" title="题目1(栈)"></a>题目1(栈)</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">[18, 19, 20, 21, 22]。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">        <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">            out.push(in.pop());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-优先队列-大根堆"><a href="#题目2-优先队列-大根堆" class="headerlink" title="题目2(优先队列-大根堆)"></a>题目2(优先队列-大根堆)</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="大小为-K-的最小堆"><a href="#大小为-K-的最小堆" class="headerlink" title="大小为 K 的最小堆"></a>大小为 K 的最小堆</h3><ul><li>复杂度：O(NlogK) + O(K)</li><li>特别适合处理海量数据</li></ul><p>维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。</p><p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p><p>Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -&gt; o2 - o1 来实现大顶堆。其它语言也有类似的堆数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; k)</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-双指针"><a href="#题目3-双指针" class="headerlink" title="题目3(双指针)"></a>题目3(双指针)</h2><p>实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>使用一个额外的 minStack，栈顶元素为当前栈中最小的值。在对栈进行 push 入栈和 pop 出栈操作时，同样需要对 minStack 进行入栈出栈操作，从而使 minStack 栈顶元素一直为当前栈中最小的值。在进行 push 操作时，需要比较入栈元素和当前栈中最小值，将值较小的元素 push 到 minStack 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    dataStack.push(node);</span><br><span class="line">    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataStack.pop();</span><br><span class="line">    minStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题四</title>
      <link href="2022/02/28/shua-ti-si/"/>
      <url>2022/02/28/shua-ti-si/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-2-28"><a href="#刷题—2022-2-28" class="headerlink" title="刷题—2022-2-28"></a>刷题—2022-2-28</h1><h2 id="题目1-数组穷举"><a href="#题目1-数组穷举" class="headerlink" title="题目1(数组穷举)"></a>题目1(数组穷举)</h2><p>输出所有和为 S 的连续正数序列。例如和为 100 的连续序列有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">[18, 19, 20, 21, 22]。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题目中的连续正数序列即为公差为1的等差递增数列，在此对应的求和公式为：<strong>Sn=(a1+an)(an-a1+1)/2</strong>；</li><li>由于序列要求至少包括两个数，序列内按照从小至大的顺序；</li><li>采取的<strong>策略</strong>是每次遍历的时候<strong>固定a1（首项），寻找符合条件的an（尾项）</strong>；</li><li>注意观察到符合条件的最后一组序列存在一种规律，a1在范围**[ 1, sum/2 ]**内取值，作为外层循环，首项不会超过sum的一半，尾项不超过sum的一半加1，利用好这个规律 <strong>遍历的时候可缩小范围</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">           ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span>(sum&lt;<span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">1</span>;left&lt;=sum/<span class="number">2</span>;left++) &#123;<span class="comment">//等差数列首项a1=left</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> right=sum/<span class="number">2</span>+<span class="number">1</span>;right&gt;left;right--) &#123;<span class="comment">//等差数列尾项an=right</span></span><br><span class="line">                   <span class="keyword">if</span>(sum*<span class="number">2</span>==(left+right)*(right-left+<span class="number">1</span>)) &#123;</span><br><span class="line">                       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">int</span> k=left;k&lt;=right;k++) list.add(k);</span><br><span class="line">                       res.add(list);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//left固定时，right最大的时候等差数列的和都比sum小，right--后更不可能相等</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(sum*<span class="number">2</span>&gt;(left+right)*(right-left+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-双指针"><a href="#题目2-双指针" class="headerlink" title="题目2(双指针)"></a>题目2(双指针)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;I am a student.&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;student. a am I&quot;</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>先翻转每个单词，再翻转整个字符串。</p><p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.length();</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == n || chars[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(c, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = c[i];</span><br><span class="line">    c[i] = c[j];</span><br><span class="line">    c[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-双指针"><a href="#题目3-双指针" class="headerlink" title="题目3(双指针)"></a>题目3(双指针)</h2><p>将字符串 S 从第 K 位置分隔成两个子字符串，并交换这两个子字符串的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S&#x3D;&quot;abcXYZdef&quot;</span><br><span class="line">K&#x3D;3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;XYZdefabc&quot;</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= str.length())</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, n, chars.length - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(chars, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题三</title>
      <link href="2022/02/27/shua-ti-san/"/>
      <url>2022/02/27/shua-ti-san/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-2-27"><a href="#刷题—2022-2-27" class="headerlink" title="刷题—2022-2-27"></a>刷题—2022-2-27</h1><h2 id="题目1-队列"><a href="#题目1-队列" class="headerlink" title="题目1(队列)"></a>题目1(队列)</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。</p><p>使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.lang.Character;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] charCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (charCnt[ch]++ == <span class="number">0</span>) <span class="comment">//新来的单身字符，入队</span></span><br><span class="line">            queue.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Character CHAR = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((CHAR = queue.peek()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = CHAR.charValue();</span><br><span class="line">            <span class="keyword">if</span> (charCnt[c] == <span class="number">1</span>) <span class="comment">//判断是否脱单了，没脱单则输出</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">else</span> queue.remove(); <span class="comment">//脱单了就移出队列，它不会再回来了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>; <span class="comment">//队空，返回#</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-数组"><a href="#题目2-数组" class="headerlink" title="题目2(数组)"></a>题目2(数组)</h2><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。</p><p>考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        cnts[str.charAt(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        <span class="keyword">if</span> (cnts[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-双指针"><a href="#题目3-双指针" class="headerlink" title="题目3(双指针)"></a>题目3(双指针)</h2><p>在有序数组中找出两个数，使得和为给定的数 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i] + nums[j];</span><br><span class="line">        <span class="keyword">if</span> (cur == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[j]));</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; target)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题二</title>
      <link href="2022/02/26/shua-ti-er-2022.2.26/"/>
      <url>2022/02/26/shua-ti-er-2022.2.26/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-2-26"><a href="#刷题—2022-2-26" class="headerlink" title="刷题—2022-2-26"></a>刷题—2022-2-26</h1><h2 id="题目1-数组"><a href="#题目1-数组" class="headerlink" title="题目1(数组)"></a>题目1(数组)</h2><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><p>③ 当 P2 遇到 P1 时（P2 &lt;= P1），或者遍历结束（P1 &lt; 0），退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P1=str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;P1;i++)</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> P2=str.length-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(P1&gt;=<span class="number">0</span>&amp;&amp;P2&gt;P1)&#123;</span><br><span class="line">        <span class="keyword">char</span> c=str.CharAt(P1--);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            str.setCharAt(P2--,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            str.setCharAt(P2--,<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">            str.setCharAt(P2--,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str.setCharAt(P2--,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-优先队列"><a href="#题目2-优先队列" class="headerlink" title="题目2(优先队列)"></a>题目2(优先队列)</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"><span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span></span><br><span class="line"><span class="comment">         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">        left.add(val);</span><br><span class="line">        right.add(left.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.add(val);</span><br><span class="line">        left.add(right.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    N++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-数组"><a href="#题目3-数组" class="headerlink" title="题目3(数组)"></a>题目3(数组)</h2><p><img src="https://camo.githubusercontent.com/00a529441d838ba0045ce2b217b6bfcc6b7bfbca85003c0dba5c5d314ab1a351/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130343031303334393239362e706e67" alt="img"></p><p>按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-&gt;从上到下打印最右一行-&gt;从右到左打印最下一行-&gt;从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][]matrix)</span></span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; ret=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">int</span> r1=<span class="number">0</span>,r2=matrix.length-<span class="number">1</span>,c1=<span class="number">0</span>,c2=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="comment">// 上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c1; i &lt;= c2; i++)</span><br><span class="line">            ret.add(matrix[r1][i]);</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r1 + <span class="number">1</span>; i &lt;= r2; i++)</span><br><span class="line">            ret.add(matrix[i][c2]);</span><br><span class="line">        <span class="keyword">if</span> (r1 != r2)</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = c2 - <span class="number">1</span>; i &gt;= c1; i--)</span><br><span class="line">                ret.add(matrix[r2][i]);</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2)</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r2 - <span class="number">1</span>; i &gt; r1; i--)</span><br><span class="line">                ret.add(matrix[i][c1]);</span><br><span class="line">        r1++; r2--; c1++; c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题一</title>
      <link href="2022/02/25/shua-ti-2022-2-25/"/>
      <url>2022/02/25/shua-ti-2022-2-25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题—2022-2-25"><a href="#刷题—2022-2-25" class="headerlink" title="刷题—2022-2-25"></a>刷题—2022-2-25</h1><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>在一个长度为n的数组里所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>要求时间复杂度O(N),空间复杂度O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在[0,n-1]范围内的问题，可以将值为i的元素调整到第i个元素位置上求解。在调整过程中，如果第i位置上已经有一个值为i的元素，就可以知道i值重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"> <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">             <span class="keyword">return</span> nums[i];</span><br><span class="line">         &#125;</span><br><span class="line">         swap(nums,i,nums[i]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j]= t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target &#x3D; 5, return true.</span><br><span class="line">Given target &#x3D; 20, return false.</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> [][] matrix)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length ==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length,cols=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c=cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt;= rows - <span class="number">1</span>&amp;&amp; c&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==matrix[r][c])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p><p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popSequence 的第一个元素，如果是的话则执行出栈操作并将 popSequence 往后移一位，继续进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushSequence,<span class="keyword">int</span> [] popSequence)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = pushSequence.length;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pushIndex=<span class="number">0</span>,popIndex = <span class="number">0</span>; pushIndex &lt; n;pushIndex++)&#123;</span><br><span class="line">        stack.push(pushSequence[pushIndex]);</span><br><span class="line">        <span class="keyword">while</span>(popIndex &lt; n &amp;&amp; !stack.isEmpty()&amp;&amp;</span><br><span class="line">             stack.peek() == popSequence[popIndex])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 执行原理</title>
      <link href="2021/05/16/spring-mvc-zhi-xing-yuan-li/"/>
      <url>2021/05/16/spring-mvc-zhi-xing-yuan-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-MVC-执行原理"><a href="#Spring-MVC-执行原理" class="headerlink" title="Spring MVC 执行原理"></a>Spring MVC 执行原理</h1><p><img src="https://study-java.oss-cn-beijing.aliyuncs.com/JAVA/SpringMVC/2020071709495130.png"></p><p><strong>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200611074159497.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDMxMTcx,size_16,color_FFFFFF,t_70"></p><ol><li>用户发送请求至前端控制器DispatcherServlet，进行分发处理。</li><li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作。</li><li>执行处理器Handler(Controller，也叫页面控制器)。</li><li>Handler执行完成返回ModelAndView。</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li><li>最终DispatcherServlet响应用户。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重庆欢乐谷一日游</title>
      <link href="2021/04/05/chong-qing-huan-le-gu-yi-ri-you/"/>
      <url>2021/04/05/chong-qing-huan-le-gu-yi-ri-you/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="欢乐谷一日游"><a href="#欢乐谷一日游" class="headerlink" title="欢乐谷一日游"></a>欢乐谷一日游</h2><p>前言：如期而至的清明节，如约而至的little team,轻松的踏上happy的欢乐谷之旅。</p><h2 id="游玩照片"><a href="#游玩照片" class="headerlink" title="游玩照片"></a>游玩照片</h2><h3 id="沉重的大摆锤"><a href="#沉重的大摆锤" class="headerlink" title="沉重的大摆锤"></a>沉重的大摆锤</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc906a1efafa27cee14dd9fe64ffac086?method=download&shareKey=9a955fa4ec829d90a29a8848ec88ff5e"></p><h3 id="摩天轮上的4个靓仔"><a href="#摩天轮上的4个靓仔" class="headerlink" title="摩天轮上的4个靓仔"></a>摩天轮上的4个靓仔</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5f4d2c683e239da2d1e34b31b5a852b?method=download&shareKey=30eab2f5640c7f1492263cf9ab983876"><br><img src="https://note.youdao.com/yws/api/personal/file/WEBa9886846520ec619c8c3802cb8e65aca?method=download&shareKey=d6da0d9ee8157c9af2b8a4570017b8e5"></p><h3 id="复古少年"><a href="#复古少年" class="headerlink" title="复古少年"></a>复古少年</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6876eaa4118ee058ab8dea7ff3b7bb67?method=download&shareKey=0c13e7004e3e67d932484f0c44e9bc07"></p><h3 id="抓拍摩天轮上的lovers"><a href="#抓拍摩天轮上的lovers" class="headerlink" title="抓拍摩天轮上的lovers"></a>抓拍摩天轮上的lovers</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa915b32c303cb98a117fb96994f29fc2?method=download&shareKey=48482285198e03d294f20bd0bf9325c2"></p><h3 id="激流勇进的瀑布"><a href="#激流勇进的瀑布" class="headerlink" title="激流勇进的瀑布"></a>激流勇进的瀑布</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB50fb023996993effc0c9972a55d33c00?method=download&shareKey=a21767ad6d501c1c45309ebdc800517e"></p><h3 id="夜晚下的重庆之眼"><a href="#夜晚下的重庆之眼" class="headerlink" title="夜晚下的重庆之眼"></a>夜晚下的重庆之眼</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB013cd5e0c19e76e960ef879246fa842c?method=download&shareKey=237043d621803311e1fec5660b0024fd"></p><h3 id="左视图的重庆之眼"><a href="#左视图的重庆之眼" class="headerlink" title="左视图的重庆之眼"></a>左视图的重庆之眼</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0a8c57f43a1bfeea72f1ac236d11fc60?method=download&shareKey=3aca6db03882a2663e78f10331c47ced"></p><h3 id="夜色下重庆的天空"><a href="#夜色下重庆的天空" class="headerlink" title="夜色下重庆的天空"></a>夜色下重庆的天空</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB5dea9202c6d93bd53b70a2977042c03a?method=download&shareKey=ea0145c934ca98763e4ab3b64ab5d8f5"></p><h3 id="鸟瞰重庆"><a href="#鸟瞰重庆" class="headerlink" title="鸟瞰重庆"></a>鸟瞰重庆</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB30a16853ff746082cf7bba8ff54e9466?method=download&shareKey=a23e6c5d3cc38d998f546db24f232d28"></p><h3 id="抓拍蕾姆"><a href="#抓拍蕾姆" class="headerlink" title="抓拍蕾姆"></a>抓拍蕾姆</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB28de79d4801a2c3df7e00dacd2817dbe?method=download&shareKey=a2625a96c036fff1e76f434d6584e63a"></p><h3 id="模糊少年"><a href="#模糊少年" class="headerlink" title="模糊少年"></a>模糊少年</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb5830fbf3528064e55fcd3f9ac3a51a1?method=download&shareKey=deffdf968e71f016b927274fdd79714f"></p><h3 id="hansome-少年"><a href="#hansome-少年" class="headerlink" title="hansome 少年"></a>hansome 少年</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7a6d73336de6646022d8a04be11933eb?method=download&shareKey=800ef2bd5535587a9d9cc5b28eebe429"></p><h3 id="粉红的白鹤"><a href="#粉红的白鹤" class="headerlink" title="粉红的白鹤"></a>粉红的白鹤</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8359d63749c3765d7da9281c9f246208?method=download&shareKey=1ac96d634abe69e008cc2fd8ffe5b1f2"></p><h3 id="永不服输的6个少年"><a href="#永不服输的6个少年" class="headerlink" title="永不服输的6个少年"></a>永不服输的6个少年</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6011cd39f70e607628fd2d60d72d4635?method=download&shareKey=535649ebb9389b4efb1c75a7aa3cea4b"></p><h3 id="按摩会所的男模"><a href="#按摩会所的男模" class="headerlink" title="按摩会所的男模"></a>按摩会所的男模</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbfdc3a243a6d572758378088c9bef646?method=download&shareKey=38db5b5524efa8a43689c575d4fcd191"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB5aa4dae827020d38313562becb04f33d?method=download&shareKey=80f897a37761a3fee9822af14a524fe1"></p><hr><h4 id="NOW-告别放假的热情，准备工作的冷静。"><a href="#NOW-告别放假的热情，准备工作的冷静。" class="headerlink" title="NOW:告别放假的热情，准备工作的冷静。"></a>NOW:告别放假的热情，准备工作的冷静。</h4><h3 id="彩蛋-男的女的折磨-痛苦面具"><a href="#彩蛋-男的女的折磨-痛苦面具" class="headerlink" title="彩蛋 (男的女的折磨 痛苦面具)"></a>彩蛋 (男的女的折磨 痛苦面具)</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6ea5ae6fe1c7a6b335cd4558bd3dfe0d?method=download&shareKey=3c0e54d79388a474ace806bf01f2a5a6"></p><h3 id="第一次按摩体验"><a href="#第一次按摩体验" class="headerlink" title="第一次按摩体验"></a>第一次按摩体验</h3><div><iframe width="400" height="200" src="//player.bilibili.com/player.html?aid=672393091&bvid=BV15U4y1Y7pn&cid=320128830&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 休闲娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="2021/04/03/wo-de-di-yi-pian-bo-ke/"/>
      <url>2021/04/03/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>第一次搭建个人博客，之后还要后续完善，并且分享自己的学习经验和生活,欢迎大家来浏览</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdik.img.kttpdq.com%2Fpic%2F101%2F70661%2Fadd59b8c29886a2d_1440x900.jpg&refer=http%3A%2F%2Fdik.img.kttpdq.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1620020429&t=7414a3a4bb4f5a3d023e7a1fc9881176"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello my world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
